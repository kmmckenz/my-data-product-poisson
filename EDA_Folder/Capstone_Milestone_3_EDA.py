from flask import Flask, render_template_string
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import scipy.stats as stats
import statistics
import numpy as np
import os
import math
import graphviz
from graphviz import Digraph
import matplotlib.image as mpimg
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import time
from urllib.request import urlopen
#loads necessary packages

# # Help
# 
# ### Purpose:
# To explore data prior to modeling.
# 
# ### How to Run:
# - Run each cell in order (previous generated information may not be captured otherwise).
# - Modify the data and graphs techniques as needed.
# 
# ### What You'll Get:
# - Prints and descriptions of the data set.
# - Exploration of any variables that may need their type changed.
# - Visualizations, including box plots, histograms, and scatterplots.
# - Interactive visualizations, allowing for change of specific country or all data, with box plots, histograms, and line graphs.
# - World map interactive visualizations showing individualized and cummulative data.
# - Explorations of seasonality and trends.
# 
# ### Functions Included:
# - pd.read_csv()
# - print ()
# - head()
# - tail()
# - sum()
# - describe()
# - unique()
# - pd.DataFrame()
# - rolling()
# - groupby()
# - diff()
# - stats.ttest_ind()
# - cumsum()
# - plot() and relevant graphing functions
# - go.Figure() and relevant graphing functions
# - px.choropleth() and relevant graphing functions
# - boxplot() and relevant graphing functions
# - scatter() and relevant graphing functions
# - hist() and relevant graphing functions
# 
# Please use the `help(function_name)` in a new cell to learn more about any functions.
# 
# Additional note: The interpretations are based on the results last generated by the developer. Any modifications to the data or the process will change the results, and will require new interpretations to be developed.

log_content = []  # Create a global list to store log content

def log_step(step_name):
    try:
        timestamp = time.strftime('%Y-%m-%d %H:%M:%S')
        log_message = f"[{timestamp}] {step_name}"
        log_content.append(log_message)  
        return log_message
    except Exception as e:
        log_message = f"An unexpected error occurred: {e}"
        log_content.append(log_message)
        return log_message
# logs steps

def load_data():
    try:
        log_step("Starting to load data")
        file_paths = [
            "/workspaces/my-data-product-poisson/Data/data_clean.csv",
            "/workspaces/my-data-product-poisson/Data/data_nomean_out.csv",
            "/workspaces/my-data-product-poisson/Data/data_nomedian_out.csv",
            "/workspaces/my-data-product-poisson/Data/data_log.csv"
        ]
        for path in file_paths:
            if not os.path.exists(path):
                log_step(f"File does not exist: {path}")
                return None
            else:
                log_step(f"File exists: {path}")
        
        # Load CSV files into pandas dataframes
        data_clean = pd.read_csv(file_paths[0])
        data_nomean_out = pd.read_csv(file_paths[1])
        data_nomedian_out = pd.read_csv(file_paths[2])
        data_log = pd.read_csv(file_paths[3])

        log_step("Data loaded successfully")
        return data_clean, data_nomean_out, data_nomedian_out, data_log
    except Exception as e:
        log_step(f"Error loading data: {e}")
        return None
    # gives error message

    # Function to load data from CSV or JSON URL
#def load_data(url):
#    try:
#        if url.endswith('.csv'):
#            df = pd.read_csv(url)
#            return df, "CSV loaded successfully."
#        elif url.endswith('.json'):
#            df = pd.read_json(url)
#            return df, "JSON loaded successfully."
#        else:
#            return None, "Unsupported file type. Please enter a .csv or .json URL."
#    except Exception as e:
#        return None, f"An error occurred: {str(e)}"
# loads data

def data_describe(data_clean, data_nomean_out, data_nomedian_out, data_log):
    print("Data Clean Summary Statistics")
    print(data_clean.describe())  
    print("Data with Outliers Removed by Standard Deviations Away Summary Statistics")
    print(data_nomean_out.describe())  
    print("Data with Outliers Removed by IQRs Away Summary Statistics")
    print(data_nomedian_out.describe())  
    print("Data with Logarithmic Transformation Summary Statistics")
    print(data_log.describe())
# prints data summaries

def create_box_plot1_vaccine(data_clean, selected_country=None):
    log_step("Starting to create the box plot.")  # Log start of plot creation
    
    if selected_country:
        data_clean = data_clean[data_clean["Entity"] == selected_country]  # Filter by selected country

    unique_countries = data_clean["Entity"].unique()

    fig_box = go.Figure()

    # Add traces for each country
    for country in unique_countries:
        country_data = data_clean[data_clean["Entity"] == country]
        fig_box.add_trace(
            go.Box(
                y=country_data["COVID-19 doses (daily)"],  # Replace with column name for the data you are using
                name=country,
                visible=False  # Initially hide all countries
            )
        )

    # Create dropdown buttons for each country
    dropdown_buttons = [
        {
            "label": country,
            "method": "update",
            "args": [{"visible": [country == c for c in unique_countries]}]
        }
        for country in unique_countries
    ]
    
    # Add a "Show All" option
    dropdown_buttons.insert(0, {
        "label": "Show All",
        "method": "update",
        "args": [{"visible": [True] * len(unique_countries)}]
    })
    
    # Update layout to include dropdown
    fig_box.update_layout(
        updatemenus=[{
            "buttons": dropdown_buttons,
            "direction": "down",
            "showactive": True,
        }],
        title="COVID-19 Vaccinations Box Plot (for data_clean)",
        yaxis_title="COVID-19 Vaccinations",
    )

    # Convert the Plotly figure to an HTML div that can be embedded
    log_step("Box plot created successfully.")  # Log successful plot creation
    return fig_box.to_html(full_html=False)

def create_box_plot1_death(data_clean, selected_country=None):
    log_step("Starting to create the box plot.")  # Log start of plot creation
    
    if selected_country:
        data_clean = data_clean[data_clean["Entity"] == selected_country]  # Filter by selected country

    unique_countries = data_clean["Entity"].unique()

    fig_box = go.Figure()

    # Add traces for each country
    for country in unique_countries:
        country_data = data_clean[data_clean["Entity"] == country]
        fig_box.add_trace(
            go.Box(
                y=country_data["Daily new confirmed deaths due to COVID-19"],  # Replace with column name for the data you are using
                name=country,
                visible=False  # Initially hide all countries
            )
        )

    # Create dropdown buttons for each country
    dropdown_buttons = [
        {
            "label": country,
            "method": "update",
            "args": [{"visible": [country == c for c in unique_countries]}]
        }
        for country in unique_countries
    ]
    
    # Add a "Show All" option
    dropdown_buttons.insert(0, {
        "label": "Show All",
        "method": "update",
        "args": [{"visible": [True] * len(unique_countries)}]
    })
    
    # Update layout to include dropdown
    fig_box.update_layout(
        updatemenus=[{
            "buttons": dropdown_buttons,
            "direction": "down",
            "showactive": True,
        }],
        title="COVID-19 Related Deats Box Plot (for data_clean)",
        yaxis_title="COVID-19 Related Deaths",
    )

    # Convert the Plotly figure to an HTML div that can be embedded
    log_step("Box plot created successfully.")  # Log successful plot creation
    return fig_box.to_html(full_html=False)

def create_hist1_vaccine(data_clean, selected_country=None):
    log_step("Starting to create the histogram.")  # Log start of plot creation
    
    if selected_country:
        data_clean = data_clean[data_clean["Entity"] == selected_country]  # Filter by selected country

    unique_countries = data_clean["Entity"].unique()

    fig_hist = go.Figure()

    # Add traces for each country
    for country in unique_countries:
        country_data = data_clean[data_clean["Entity"] == country]
        fig_hist.add_trace(
            go.Histogram(
                y=country_data["COVID-19 doses (daily)"],  # Replace with column name for the data you are using
                name=country,
                visible=False  # Initially hide all countries
            )
        )

    # Create dropdown buttons for each country
    dropdown_buttons = [
        {
            "label": country,
            "method": "update",
            "args": [{"visible": [country == c for c in unique_countries]}]
        }
        for country in unique_countries
    ]
    
    # Add a "Show All" option
    dropdown_buttons.insert(0, {
        "label": "Show All",
        "method": "update",
        "args": [{"visible": [True] * len(unique_countries)}]
    })
    
    # Update layout to include dropdown
    fig_hist.update_layout(
        updatemenus=[{
            "buttons": dropdown_buttons,
            "direction": "down",
            "showactive": True,
        }],
        title="COVID-19 Vaccinations Histogram (for data_clean)",
        yaxis_title="COVID-19 Vaccinations",
    )

    # Convert the Plotly figure to an HTML div that can be embedded
    log_step("Histogram created successfully.")  # Log successful plot creation
    return fig_hist.to_html(full_html=False)

def create_hist1_death(data_clean, selected_country=None):
    log_step("Starting to create the histogram.")  # Log start of plot creation
    
    if selected_country:
        data_clean = data_clean[data_clean["Entity"] == selected_country]  # Filter by selected country

    unique_countries = data_clean["Entity"].unique()

    fig_hist = go.Figure()

    # Add traces for each country
    for country in unique_countries:
        country_data = data_clean[data_clean["Entity"] == country]
        fig_hist.add_trace(
            go.Histogram(
                y=country_data["Daily new confirmed deaths due to COVID-19"],  # Replace with column name for the data you are using
                name=country,
                visible=False  # Initially hide all countries
            )
        )

    # Create dropdown buttons for each country
    dropdown_buttons = [
        {
            "label": country,
            "method": "update",
            "args": [{"visible": [country == c for c in unique_countries]}]
        }
        for country in unique_countries
    ]
    
    # Add a "Show All" option
    dropdown_buttons.insert(0, {
        "label": "Show All",
        "method": "update",
        "args": [{"visible": [True] * len(unique_countries)}]
    })
    
    # Update layout to include dropdown
    fig_hist.update_layout(
        updatemenus=[{
            "buttons": dropdown_buttons,
            "direction": "down",
            "showactive": True,
        }],
        title="COVID-19 Related Deaths Histogram (for data_clean)",
        yaxis_title="COVID-19 Related Deaths",
    )

    # Convert the Plotly figure to an HTML div that can be embedded
    log_step("Histogram created successfully.")  # Log successful plot creation
    return fig_hist.to_html(full_html=False)


    log_step("Starting to create the histogram.")  # Log start of plot creation
    
    if selected_country:
        data_log = data_log[data_log["Entity"] == selected_country]  # Filter by selected country

    unique_countries = data_log["Entity"].unique()

    fig_hist = go.Figure()

    # Add traces for each country
    for country in unique_countries:
        country_data = data_log[data_log["Entity"] == country]
        fig_hist.add_trace(
            go.Histogram(
                y=country_data["Daily new confirmed deaths due to COVID-19"],  # Replace with column name for the data you are using
                name=country,
                visible=False  # Initially hide all countries
            )
        )

    # Create dropdown buttons for each country
    dropdown_buttons = [
        {
            "label": country,
            "method": "update",
            "args": [{"visible": [country == c for c in unique_countries]}]
        }
        for country in unique_countries
    ]
    
    # Add a "Show All" option
    dropdown_buttons.insert(0, {
        "label": "Show All",
        "method": "update",
        "args": [{"visible": [True] * len(unique_countries)}]
    })
    
    # Update layout to include dropdown
    fig_hist.update_layout(
        updatemenus=[{
            "buttons": dropdown_buttons,
            "direction": "down",
            "showactive": True,
        }],
        title="COVID-19 Related Deaths Histogram (for data_log)",
        yaxis_title="COVID-19 Related Deaths",
    )

    # Convert the Plotly figure to an HTML div that can be embedded
    log_step("Histogram created successfully.")  # Log successful plot creation
    return fig_hist.to_html(full_html=False)

def create_line1_vaccine(data_clean, selected_country=None):
    log_step("Starting to create the line graph.")  # Log start of plot creation
    
    if selected_country:
        data_clean = data_clean[data_clean["Entity"] == selected_country]  # Filter by selected country

    unique_countries = data_clean["Entity"].unique()

    fig_line = go.Figure()

    # Add traces for each country
    for country in unique_countries:
        country_data = data_clean[data_clean["Entity"] == country]
        fig_line.add_trace(
            go.Scatter(
                y=country_data["COVID-19 doses (daily)"],  # Replace with column name for the data you are using
                mode='lines',
                name=country,
                visible=False  # Initially hide all countries
            )
        )

    # Create dropdown buttons for each country
    dropdown_buttons = [
        {
            "label": country,
            "method": "update",
            "args": [{"visible": [country == c for c in unique_countries]}]
        }
        for country in unique_countries
    ]
    
    # Add a "Show All" option
    dropdown_buttons.insert(0, {
        "label": "Show All",
        "method": "update",
        "args": [{"visible": [True] * len(unique_countries)}]
    })
    
    # Update layout to include dropdown
    fig_line.update_layout(
        updatemenus=[{
            "buttons": dropdown_buttons,
            "direction": "down",
            "showactive": True,
        }],
        title="COVID-19 Vaccines (daily) Line Graph (for data_clean)",
        xaxis_title="Day",
        yaxis_title="COVID-19 Vaccines (daily)",
    )

    # Convert the Plotly figure to an HTML div that can be embedded
    log_step("Line Graph created successfully.")  # Log successful plot creation
    return fig_line.to_html(full_html=False)

def create_line1_death(data_clean, selected_country=None):
    log_step("Starting to create the line graph.")  # Log start of plot creation
    
    if selected_country:
        data_clean = data_clean[data_clean["Entity"] == selected_country]  # Filter by selected country

    unique_countries = data_clean["Entity"].unique()

    fig_line = go.Figure()

    # Add traces for each country
    for country in unique_countries:
        country_data = data_clean[data_clean["Entity"] == country]
        fig_line.add_trace(
            go.Scatter(
                y=country_data["Daily new confirmed deaths due to COVID-19"],  # Replace with column name for the data you are using
                mode='lines',
                name=country,
                visible=False  # Initially hide all countries
            )
        )

    # Create dropdown buttons for each country
    dropdown_buttons = [
        {
            "label": country,
            "method": "update",
            "args": [{"visible": [country == c for c in unique_countries]}]
        }
        for country in unique_countries
    ]
    
    # Add a "Show All" option
    dropdown_buttons.insert(0, {
        "label": "Show All",
        "method": "update",
        "args": [{"visible": [True] * len(unique_countries)}]
    })
    
    # Update layout to include dropdown
    fig_line.update_layout(
        updatemenus=[{
            "buttons": dropdown_buttons,
            "direction": "down",
            "showactive": True,
        }],
        title="COVID-19 Related Deaths Line Graph (for data_clean)",
        xaxis_title="Day",
        yaxis_title="COVID-19 Related Deaths",
    )

    # Convert the Plotly figure to an HTML div that can be embedded
    log_step("Line Graph created successfully.")  # Log successful plot creation
    return fig_line.to_html(full_html=False)


    log_step("Starting to create the line graph.")  # Log start of plot creation
    
    if selected_country:
        data_log = data_log[data_log["Entity"] == selected_country]  # Filter by selected country

    unique_countries = data_log["Entity"].unique()

    fig_line = go.Figure()

    # Add traces for each country
    for country in unique_countries:
        country_data = data_log[data_log["Entity"] == country]
        fig_line.add_trace(
            go.Scatter(
                y=country_data["Daily new confirmed deaths due to COVID-19"],  # Replace with column name for the data you are using
                mode='lines',
                name=country,
                visible=False  # Initially hide all countries
            )
        )

    # Create dropdown buttons for each country
    dropdown_buttons = [
        {
            "label": country,
            "method": "update",
            "args": [{"visible": [country == c for c in unique_countries]}]
        }
        for country in unique_countries
    ]
    
    # Add a "Show All" option
    dropdown_buttons.insert(0, {
        "label": "Show All",
        "method": "update",
        "args": [{"visible": [True] * len(unique_countries)}]
    })
    
    # Update layout to include dropdown
    fig_line.update_layout(
        updatemenus=[{
            "buttons": dropdown_buttons,
            "direction": "down",
            "showactive": True,
        }],
        title="COVID-19 Related Deaths Line Graph (data_log)",
        xaxis_title="Day",
        yaxis_title="COVID-19 Related Deaths",
    )

    # Convert the Plotly figure to an HTML div that can be embedded
    log_step("Line Graph created successfully.")  # Log successful plot creation
    return fig_line.to_html(full_html=False)

def create_scatter1(data_clean, selected_country=None):
    log_step("Starting to create the scatter plot.")  # Log start of plot creation
    
    if selected_country:
        data_clean = data_clean[data_clean["Entity"] == selected_country]  # Filter by selected country

    unique_countries = data_clean["Entity"].unique()

    fig_scatter = go.Figure()

    # Add traces for each country
    for country in unique_countries:
        country_data = data_clean[data_clean["Entity"] == country]
        fig_scatter.add_trace(
            go.Scatter(
                x=country_data["COVID-19 doses (daily)"],
                y=country_data["Daily new confirmed deaths due to COVID-19"],  # Replace with column name for the data you are using
                mode='markers',
                name=country,
                visible=False  # Initially hide all countries
            )
        )

    # Create dropdown buttons for each country
    dropdown_buttons = [
        {
            "label": country,
            "method": "update",
            "args": [{"visible": [country == c for c in unique_countries]}]
        }
        for country in unique_countries
    ]
    
    # Add a "Show All" option
    dropdown_buttons.insert(0, {
        "label": "Show All",
        "method": "update",
        "args": [{"visible": [True] * len(unique_countries)}]
    })
    
    # Update layout to include dropdown
    fig_scatter.update_layout(
        updatemenus=[{
            "buttons": dropdown_buttons,
            "direction": "down",
            "showactive": True,
        }],
        title="Scatter Plot of COVID-19 Vaccines (daily) against Daily COVID-19 related Deaths (for data_clean)",
        xaxis_title="Daily new confirmed deaths due to COVID-19",
        yaxis_title="COVID-19 Vaccines (daily)",
    )

    # Convert the Plotly figure to an HTML div that can be embedded
    log_step("Scatter plot created successfully.")  # Log successful plot creation
    return fig_scatter.to_html(full_html=False)


    log_step("Starting to create the scatter plot.")  # Log start of plot creation
    
    if selected_country:
        data_log = data_log[data_log["Entity"] == selected_country]  # Filter by selected country

    unique_countries = data_log["Entity"].unique()

    fig_scatter = go.Figure()

    # Add traces for each country
    for country in unique_countries:
        country_data = data_log[data_log["Entity"] == country]
        fig_scatter.add_trace(
            go.Scatter(
                x=country_data["COVID-19 doses (daily)"],
                y=country_data["Daily new confirmed deaths due to COVID-19"],  # Replace with column name for the data you are using
                mode='markers',
                name=country,
                visible=False  # Initially hide all countries
            )
        )

    # Create dropdown buttons for each country
    dropdown_buttons = [
        {
            "label": country,
            "method": "update",
            "args": [{"visible": [country == c for c in unique_countries]}]
        }
        for country in unique_countries
    ]
    
    # Add a "Show All" option
    dropdown_buttons.insert(0, {
        "label": "Show All",
        "method": "update",
        "args": [{"visible": [True] * len(unique_countries)}]
    })
    
    # Update layout to include dropdown
    fig_scatter.update_layout(
        updatemenus=[{
            "buttons": dropdown_buttons,
            "direction": "down",
            "showactive": True,
        }],
        title="Scatter Plot of COVID-19 Vaccines (daily) against Daily COVID-19 related Deaths (for data_log)",
        xaxis_title="Daily new confirmed deaths due to COVID-19",
        yaxis_title="COVID-19 Vaccines (daily)",
    )

    # Convert the Plotly figure to an HTML div that can be embedded
    log_step("Scatter plot created successfully.")  # Log successful plot creation
    return fig_scatter.to_html(full_html=False)

def rolling_means(data_clean):
    data_grouped = data_clean.groupby('Day')[['COVID-19 doses (daily)', 'Daily new confirmed deaths due to COVID-19']].sum()
    log_step("Starting to create the rolling avgs plots.")  # Log start of plot creation
    
    # Create rolling mean calculations
    data_rolling7 = data_grouped.rolling(7, min_periods=1).mean()
    data_rolling30 = data_grouped.rolling(30, min_periods=1).mean()
    data_rolling180 = data_grouped.rolling(180, min_periods=1).mean()

    # Create 7-day rolling mean graph
    fig_7 = px.line(data_rolling7, x=data_rolling7.index, y=['COVID-19 doses (daily)', 'Daily new confirmed deaths due to COVID-19'],
                    title='7-Day Rolling Mean of COVID-19 Data (for data_clean)')
    fig_7.update_layout(xaxis_title='Date', yaxis_title='7-Day Rolling Mean', 
                        legend_title='Metrics', template='plotly_dark')

    # Create 30-day rolling mean graph
    fig_30 = px.line(data_rolling30, x=data_rolling30.index, y=['COVID-19 doses (daily)', 'Daily new confirmed deaths due to COVID-19'],
                     title='30-Day Rolling Mean of COVID-19 Data (for data_clean)')
    fig_30.update_layout(xaxis_title='Date', yaxis_title='30-Day Rolling Mean', 
                         legend_title='Metrics', template='plotly_dark')

    # Create 180-day rolling mean graph
    fig_180 = px.line(data_rolling180, x=data_rolling180.index, y=['COVID-19 doses (daily)', 'Daily new confirmed deaths due to COVID-19'],
                      title='180-Day Rolling Mean of COVID-19 Data (for data_clean)')
    fig_180.update_layout(xaxis_title='Date', yaxis_title='180-Day Rolling Mean', 
                          legend_title='Metrics', template='plotly_dark')

    log_step("Rolling avg graphs created successfully.")  # Log start of plot creation
    
    # Return HTML representations of each graph
    return fig_7.to_html(), fig_30.to_html(), fig_180.to_html()

def plot_differencing(data_clean):
    data_grouped = data_clean.groupby('Day')[['COVID-19 doses (daily)', 'Daily new confirmed deaths due to COVID-19']].sum()
    log_step("Starting to create differencing plots.")
    

    fig_dif = px.line(data_grouped, x=data_grouped.index, y=['COVID-19 doses (daily)', 'Daily new confirmed deaths due to COVID-19'],
                title='Differencing of COVID-19 doses (daily) and Daily new confirmed deaths due to COVID-19 (for data_clean)')
    fig_dif.update_layout(xaxis_title='Date', yaxis_title='Differencing Results', 
                    legend_title='Metrics', template='plotly_dark')
    log_step("Differencing graphs created successfully.")
    return fig_dif.to_html()

# Function to create all interactive graphs
def creating_interactive_graphs1(data_clean, selected_country=None):
    log_step("Starting to create interactive graphs.")  # Log the start of graph creation

    # Call the box plot creation function with the selected country filter
    box_plot1_vaccine_html = create_box_plot1_vaccine(data_clean, selected_country)
    box_plot1_death_html = create_box_plot1_death(data_clean, selected_country)
    hist1_vaccine_html = create_hist1_vaccine(data_clean, selected_country)
    hist1_death_html = create_hist1_death(data_clean, selected_country)
    line1_vaccine_html = create_line1_vaccine(data_clean, selected_country)
    line1_death_html = create_line1_death(data_clean, selected_country)
    scatter1_html = create_scatter1(data_clean, selected_country)
    rolling_7_html, rolling_30_html, rolling_180_html = rolling_means(data_clean)
    fig_dif_html = plot_differencing(data_clean)

    log_step("Interactive graphs created successfully.")  # Log successful graph creation

    # Return all HTML graphs including rolling means
    return (box_plot1_vaccine_html, box_plot1_death_html,
            hist1_vaccine_html, hist1_death_html,
            line1_vaccine_html, line1_death_html,
            scatter1_html,
            rolling_7_html, rolling_30_html, rolling_180_html,
            fig_dif_html
    )
    # returns htmls

def about_eda():
    try:
        content = """A summary analysis of the original data showed that the mean number of
        COVID-19 doses was 785,359 daily, and a standard deviation of 3,270,447 was
        found. The median value of this was 22,436 and the interquartile range was
        204,958.42855. As for the confirmed deaths per day, the mean was found to be
        1,683,651, with a standard deviation of 6,389,856. The median for this was
        found to be 176,343 and the interquartile range was 1,287,971.8. Both the doses
        and deaths had means and standard deviations larger than that of the median
        and interquartile ranges found. This provides evidence that the vaccination
        doses and confirmed COVID-19 deaths are right-skewed.
        
        After outlier removing through standard deviations away and interquartile ranges
        away, the same results were found. The mean and standard deviations of COVID19 administered vaccinations were 785,359 and 3,270,447, respectively. The
        median was calculated as 22,436. For the daily confirmed deaths, the values also In [54]: In [55]: were consistent between the differing outlier removals, with the mean as
        1,683,651, standard deviation as 6,389,856, and median as 176,343. All of these
        findings are also the same as those found in the original data. Graphs after
        outlier removal techniques further show limited change in the data, as the
        histograms are structured the same.
        
        The logarithmic transformation, on the other hand, did exemplify differences
        made upon the data set. For COVID-19 doses (daily), the mean became
        9.658036, the standard deviations became 3.609422, and the median became
        10.018467. The histogram post-transformation shows a more normal
        distribution. With the daily new confirmed deaths, the mean transformed to
        8.522092, the standard deviation to 6.585103, and the median to 12.080192.
        This graph appears to now be bimodal, with a large presence at zero and then a
        slightly left skewed distribution about the median.
        
        Images five and six were created to show the potential trends and seasonality
        within the data. While doses administered were high in 2021, there appears to
        be a downward trend to the data. No seasonality is outwardly apparent, as all of
        the peaks appear to be in the year 2021 and steady out over time. COVID-19
        related deaths did not show any seasonality as well, due to most of the
        significant peaks showing in the year 2021. There does appear to be potential for
        a downward trend for the deaths, as they do appear to mostly decrease after
        2021.

        A scatterplot was also created to show the potential relationship between COVID-19 doses 
        and COVID-19 related deaths. There appears to be a strong, negative relationship between
        the two variables. Their relationship is statistically significant, as confirmed by the
        p-value between them, found to be 9.152921412001677e-230."""
        return content
    except Exception as e:
        log_step(f"An unexpected error occurred: {e}")
        return None
    # returns error
# prints message for user to read