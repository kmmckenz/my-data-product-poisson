import pandas as pd
import numpy as np
import time
from sklearn.model_selection import train_test_split
from sklearn.linear_model import PoissonRegressor
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.model_selection import cross_validate
import matplotlib.pyplot as plt
import os

# # Help
# 
# ### Purpose:
# To build Poisson Regression models and generate reports.
# 
# ### How to Run:
# - Run each cell in order (previous generated information may not be captured otherwise).
# - Modify the data, model and their features as needed.
# 
# ### What You'll Get:
# - Printed and saved reports of MSE, R-squared, and cross validation results (as .txt files).
# - Printed and saved observed vs. predicted value graphs (as PNG images).
# 
# ### Functions Included:
# - pd.read_csv()
# - train_test_split()
# - linear_model.PoissonRegressor()
# - fit()
# - predict()
# - scatter(), as well as other releavant graphing functions
# - mean_squared_error()
# - r2_score()
# - cross_validate()
# - print()
# 
# Please use the `help(function_name)` in a new cell to learn more about any functions.
# 
# Additional note: The interpretation is based on the model last generated by the developer. Any newly completed iterations will change the training and testing split of the data, which may impact the results. Any modifications also would alter the results. New interpretations would be required.

# Logging function
def log_step(step_name):
    log_message = f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] {step_name}"
    print(log_message)  # Print log to console
    return log_message  


# Data loading function

# Function to load data from CSV or JSON URL
#def load_data(url):
#    try:
#        if url.endswith('.csv'):
#            df = pd.read_csv(url)
#            return df, "CSV loaded successfully."
#        elif url.endswith('.json'):
#            df = pd.read_json(url)
#            return df, "JSON loaded successfully."
#        else:
#            return None, "Unsupported file type. Please enter a .csv or .json URL."
#    except Exception as e:
#        return None, f"An error occurred: {str(e)}"

def load_data():
    # Define the correct data folder path
    data_folder = '/workspaces/my-data-product-poisson/Data/'

    # Verify that the folder exists
    if not os.path.exists(data_folder):
        print(f"Data folder not found: {data_folder}")
        return None

    try:
        # Ensure the correct file paths by joining with the data folder
        data_clean = pd.read_csv(os.path.join(data_folder, 'data_clean.csv'))
        data_nomean_out = pd.read_csv(os.path.join(data_folder, 'data_nomean_out.csv'))
        data_nomedian_out = pd.read_csv(os.path.join(data_folder, 'data_nomedian_out.csv'))
        data_log = pd.read_csv(os.path.join(data_folder, 'data_log.csv'))

        # Return the loaded data
        return data_clean, data_nomean_out, data_nomedian_out, data_log

    except FileNotFoundError as e:
        print(f"Error: {e}")
        return None
    except Exception as e:
        print(f"Error loading data: {e}")
        return None

# Train-test split and modeling function
def train_poisson_model(X, y):
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    clf = PoissonRegressor()
    model = clf.fit(X_train.values.reshape(-1, 1), y_train)
    predictions = clf.predict(X_test.values.reshape(-1, 1))
    
    score = clf.score(X_test.values.reshape(-1, 1), y_test)
    mse = mean_squared_error(y_test, predictions)
    
    return model, predictions, score, mse, X_test, y_test

# Model evaluation function
def evaluate_model(y_test, predictions):
    mse = mean_squared_error(y_test, predictions)
    r2 = r2_score(y_test, predictions)
    return mse, r2

# Cross-validation function
def cross_validate_model(clf, X_train, y_train):
    cv_results = cross_validate(clf, X_train.values.reshape(-1, 1), y_train,
                                cv=5,
                                scoring=['neg_mean_squared_error', 'r2'],
                                return_train_score=True)
    return cv_results

# Visualization function
def visualize_predictions(y_test, predictions, title="Observed vs. Predicted"):
    plt.scatter(y_test, predictions, label='Predictions')
    plt.plot([min(y_test), max(y_test)], [min(predictions), max(predictions)], linestyle='--', color='red', label='Perfect Prediction')
    plt.xlabel('Observed Values')
    plt.ylabel('Predicted Values')
    plt.title(title)
    plt.legend()
    plt.show()
